正常情况下，TCP建立连接需要进行三次握手，断开连接需要四次挥手：

## 1.	三次握手建立连接：

建立连接请求都是由客户端主动向服务端发起

### 连接前准备：

服务端（在客户端之前启动）：

1. 创建套接字（Socket结构体  sip(地址) sport(端口信息)）
2. 为套接字绑定地址信息
3. 开始监听（LISTEN状态）

客户端：

1. 创建套接字（Socket结构体  sip(地址) sport(端口信息)）
2. 为套接字绑定地址信息
3. 先服务端发送连接请求

### 建立连接过程（三次握手）：

1. 客户端向服务端发送SYN请求(连接请求，同步报文段)

   **这一动作完成之后客户端处于SYN_SEND状态，等待服务端发送SYN和ACK**

2. 服务端收到SYN请求后，创建新的套接字专门用来处理这一个连接（将该连接放入内核等待队列中），再向客户端发送SYN请求和ACK（确认报文）回复

   **这一动作完成之后服务端处于SYN_RCVD状态,等待客户端下一次回复的ACK**

3. 客户端收到服务端回复的ACK之后，确认对方具有收发数据能力，再次向服务端回复ACK

   **这一动作完成之后客户端处于ESTABLISHED（就绪状态），此时客户端已准备成功，链接已建立，只需要等服务端收到此ACK之后，服务器端也将由SYN_RCVD状态转换为ESTABLISHED状态，双方就连接建立成功了**

## 2.  四次挥手断开连接：

断开连接请求可以由客户端向服务端发起，也可以有服务端向客户端发起

### 断开连接过程（四次挥手）：（以客户端主动断开连接为例）

1. 客户端主动发起断开连接请求：调用close接口，向服务端发送FIN请求(断开连接请求，结束报文段)

   **这一动作完成后客户端处于FIN_WATE_1状态**

2. 服务端接收到客户端发来的FIN包，向客户端发出ACK回复

   **这一动作完成后客户端处于CLOSE_WAIT状态**

   **客户端收到ACK回复后处于FIN_WATE_2状态**

3. 完成所有数据的处理后，服务端向客户端主动发送FIN包，等待下一个ACK回复

   **这一动作完成后服务端处于LAST_ACK状态**

4. 客户端收到服务端主动发送的FIN包后向服务端发送ACK回复

   **这一动作完成后客户端处于TIME_WAIT状态，在2个MSL(报文最大生存时间)时间结束后客户端直接关闭连接（进入CLOSE状态）**

   **服务端收到客户端的ACK回复后直接关闭连接，进入CLOSE状态，至此，TCP四次挥手完成**

## 3. 其他问题：

#### 3.1	为什么握手需要三次，挥手需要四次？

先从握手三次说起，三次握手是因为两次不安全，四次没必要

因为TCP建立连接需要发送信息或者数据，必须保证通信双方都具有收发数据的能力：

按照我的理解，第一次握手成功让服务端知道客户端有发送数据的能力；第二次握手成功让客户端知道服务端有收发数据的能力；第三期握手成功让服务端知道客户端有接收数据的能力。

为什么挥手需要四次？

主动关闭方先发送断开连接请求，然后停止发送数据，被动关闭方发送ACK回复，但是由于网络传输可能有延迟，所以被动关闭方需要等待并将所有数据处理完毕，然后才能向客户端发送FIN包，客户端收到之后再向服务端回复ACK来结束双方通信。

个人认为，TCP建立连接和断开连接其实都是双方各发送一个请求和回复，但是由于在连接建立前，两端之间的“路上”没有任何数据，有TCP的捎带应答机制，可以将服务端的SYN和ACK一起发送；而断开连接时，由于可能有的数据还在“路上”，故就算服务端收到断开连接请求也无法直接关闭，而是得等到所有数据都处理结束才能主动响应这次关闭（即发送FIN包），不能捎带应答，所以断开连接过程就比建立连接多一次。

#### 3.2	TIME_WAIT存在的意义是什么，什么主动断开方在发送最后一个ACK回复之后还需要等到2个MSL?

还是因为网络传输中的延迟及重传，断开连接时处于LAST_ACK的被动关闭方在迟迟收不到主动关闭方回复的最后一个ACK时，会认为自己发送的FIN包可能丢失，所以他会重新发送一个FIN包，让主动关闭方重新回复ACK；或者，主动关闭方发送的最后一个ACk被阻塞在网络中，若立即关闭端口，如果有另一个程序立即使用这个端口，可能会接收到来自上一次连接的报文，所以等待两个MSL是为了确保在相同端口建立新的连接时网络中上一次连接产生的重复报文已经全部消失。

#### 3.3	若三次握手建立连接失败，服务端会怎么做？

若处于SYN_SEND状态的客户端收不到服务端发送的SYN和ACK，将重新向服务端发送SYN，重新请求连接

若处于SYN_RCVD的服务端收不到客户端回复的ACK，它不会向客户端重新发送FIN和ACK，而是会向客户端发送RST报文（重新连接请求），并释放本次连接的socket资源，让客户端重新发送SYN，重新开始连接。